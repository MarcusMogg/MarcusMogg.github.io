<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://codemogg.cn</id>
    <title>CodeMogg</title>
    <updated>2020-10-25T14:06:54.402Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://codemogg.cn"/>
    <link rel="self" href="https://codemogg.cn/atom.xml"/>
    <subtitle>快乐摸鱼</subtitle>
    <logo>https://codemogg.cn/images/avatar.png</logo>
    <icon>https://codemogg.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, CodeMogg</rights>
    <entry>
        <title type="html"><![CDATA[ MapReduce 部分翻译]]></title>
        <id>https://codemogg.cn/post/H0FKr9ipF/</id>
        <link href="https://codemogg.cn/post/H0FKr9ipF/">
        </link>
        <updated>2020-08-21T07:51:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="mapreduce-simplified-data-processing-on-large-clusters">MapReduce: Simplified Data Processing on Large Clusters</h2>
<p>学习MIT6.824，先看三篇经典paper</p>
<p>英语太烂了，不得不先翻译一遍……</p>
<h2 id="摘要">摘要</h2>
<p><code>MapReduce</code>是一种用于处理、生成大数据集的编程模型和相关实现。 用户指定一个<code>Map</code>函数将一个键值对生成为一组中间键值对集合，一个<code>Reduce</code>函数合并所有具有相同中间key的中间值。如paper中所示，这个模型可以表示显示世界中的许多任务。</p>
<p>以这种方式编写的程序自然地支持并行和在大规模的商用集群上运行。运行时系统负责划分输入数据、在集群上的调度、处理机器故障、管理集群内部的通信。这使得没有任何并发处理和分布式经验的程序员可以轻松的利用大规模分布式系统的资源。</p>
<p>我们MapReduce的实现运行在一个大规模的商用服务器集群上，而且可以灵活的伸缩。一个典型的MapReduce计算处理几千台机器上许多TB的数据。程序员可以发现系统使用非常简单。在谷歌的集群上，每天都有几百个MapReduce程序、一千多个个MapReduce任务执行。</p>
<h2 id="1-简介">1 简介</h2>
<p>在过去的五年里，作者和谷歌的许多员工已经实现了成百上千个特殊目的程序，用于将大量的原始数据（比如抓取的文挡、网络请求log）处理为各种衍生数据（比如倒排索引，网络文档的图结构的各种表示，每台主机爬取到的页数摘要，某一天里最频繁的请求等）。许多计算从概念上讲是很简单的。但是，输入数据是非常庞大的，计算需要分布到成百上千台机器上，这样才能在一个合理的时间内获取到结果。如何并行化计算，划分数据，处理异常这些问题通常需要大量复杂的代码去解决，使得原本简单的计算变的复杂。</p>
<p>为了解决复杂性，我们设计了一个抽象模型，使得我们可以表示需要的简单的计算，并且将并行、容错、数据划分、复杂均衡这些细节隐藏到一个库里。我们的抽象模型灵感来源于Lisp等函数式编程语言的<code>map、reduce</code>表示。我们认识到，许多计算过程都在输入中的逻辑记录上使用了map操作以处理为中间键值对，然后在所有具有相同key的value上使用reduce操作以合适地合并导出数据。函数模型的使用,再结合用户指定的map和reduce操作,让我们可以非常容易的实现大规模并行化计算,和使用再次执行作为初级机制来实现容错。</p>
<p>这份工作的主要贡献是一个简单、有效的接口可以自动并行化和分配大规模计算，结合这个接口的实现来在大量普通的PC机上实现高性能计算。</p>
<p>第二节描述了基本的编程模型并给出了一些例子。第三节介绍了我们基于集群环境的 Mapreduce 接口实现。第四节介绍了编程模型的一些技巧。第五节对我们执行各种任务的性能进行了度量。第六节介绍了MapReduce在谷歌内部的使用，包括我们以此为基础重写产品索引系统的经验。第七节是一些相关讨论和未来的工作。</p>
<h2 id="2-编程模型">2 编程模型</h2>
<p>计算利用一个输入键值对集合，产出一个输出键值对结合。MapReduce库的用户将计算表示为两个函数 <code>Map</code>和<code>Reduce</code>。</p>
<p><code>Map</code>，由用户编写，将一个键值对生成为一组中间键值对集合。MapReduce库将所有具有相同关键词<code>I</code>的中间value进行分组，然后传递给Reduce函数。</p>
<p><code>Reduce</code>函数，同样由用户编写，接受一个中间key <code>I</code>和该key相关 的一组value。它将这些值合并到一起，形成一个可能更小的value集合。通常一个Reduce调用只产生一个或者零个输出。通过一个迭代器把中间value提供给用户自定义的reduce函数。这使得我们可以处理太大以至于内存放不下的value列表。</p>
<h3 id="21-example">2.1 Example</h3>
<p>考虑这样一个问题，计算一个大规模文档集合中每个单词的数目。用户将编写和下面伪代码类似的程序</p>
<pre><code>map(String key, String value):
	// key: document name
	// value: document contents
	for each word w in value:
		EmitIntermediate(w, &quot;1&quot;);

reduce(String key, Iterator value):
	// key: a word
	// value: a list of counts
	int result = 0;
	for each v in value:
		result += ParseInt(v)
	Emit(AsString(result));
</code></pre>
<p><code>map</code>函数会发出每个单词以及相关的出现次数。<code>reduce</code>函数对一个特定单词发出的次数进行求和。</p>
<p>除此之外，用户需要编码用输入输出文件的名字和可选的调节参数来填充一个mapreduce规范（<code>mapreduce specification</code>）对象。用户之后调用MapReduce函数，传递给它规范对象。用户的代码需要和MapReduce库（C++实现）链接。附录A包含这个例子的完整代码。</p>
<h3 id="22-types">2.2 Types</h3>
<p>尽管之前的伪代码使用的是字符串输入和输出，但是从概念上讲，用户提供的map和reduce函数具有相关的类型</p>
<pre><code>map      (k1,v1)       -&gt;list(k2,v2)
reduce   (k2,list(v2)) -&gt;list(v2)
</code></pre>
<p>输入的键值对和输出的键值对来自不同的域。但是中间键值对和输出键值对来自相同的域。</p>
<p>我们的C++实现在用户实现的函数之间传递字符串，并且用户可以自行编写代码将字符串转换为适当的类型。</p>
<h3 id="23-more-examples">2.3 More Examples</h3>
<p>下面有一些有趣的程序，可以很轻松的使用MapReduce计算表示。</p>
<ul>
<li>分布式Grep：map函数发送满足特定模式的行。reduce函数仅将中间数据输出。</li>
<li>统计URL访问频率：map函数处理web页面请求的日志信息，发送<code>&lt;URL,1&gt;</code>。reduce函数将同一个URL的次数加到一起，并发送<code>&lt;URL,total cnt&gt;</code></li>
<li>反转网络链接图：map函数对<code>source</code>页面中的所有<code>target</code>连接输出<code>&lt;target,source&gt;</code>。reduce函数将指定URL相关的tsource URL放到一个列表里，返回<code>&lt;URL,list(source)&gt;</code></li>
<li>分布式排序：map函数从record中提取key，然后发送<code>&lt;key ,record&gt;</code>。reduce函数不改变键值对。这个计算依赖于4.1中介绍的划分设备(partitioning facilities  )和4.2中介绍的排序(ordering  )属性</li>
</ul>
<h2 id="3-实现">3 实现</h2>
<p>可能会有很多种不同的MapReduce实现。正确的选择取决于环境。例如，一种实现适合于小共享内存的机器，另一种实现适合于大NUMA 多处理器，还有一种适合更大的网络机器集群。</p>
<p>这一节介绍一种实现适合于谷歌内部广泛应用的环境，使用交换机连接的大规模商用计算机集群。在我们的环境里：</p>
<ul>
<li>(1) 机器通常是x86双处理器，运行Linux，内存2-4GB</li>
<li>(2) 商用网络硬件，通常100mb/s 或者 1gb/s,但是平均小于全部带宽的一半。</li>
<li>(3) 一个集群通常有成百上千台机器，所以机器故障是很常见的。</li>
<li>(4) 通过直接连接到单个计算机的廉价IDE磁盘提供存储。 内部开发的分布式文件系统用于管理存储在这些磁盘上的数据。 文件系统使用复制在不可靠的硬件上提供可用性和可靠性。</li>
<li>(5) 用户将作业提交到调度系统。 每个作业包含一组任务，并由调度程序映射到集群中的一组可用计算机</li>
</ul>
<h3 id="31-execution-overview">3.1 Execution Overview</h3>
<p>通过自动划分输入数据到M个split的集合，Map调用可以分布到多态机器上。输入split可以在不同的机器上并行处理。reduce调用实现分布式是通过一个分割函数将中间key分割为R份（例如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo>(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>R</mi></mrow><annotation encoding="application/x-tex">hash(key)\mod R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>）。分割的总数和分割函数由用户指定。</p>
<p>图一展示了我们的MapReduce实现的整体流程。当用户程序调用MapReduce函数时，会发生下面一系列操作(图1上的数字标签和下面的对应)</p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/08/18/duyRFf.png" alt="图一" loading="lazy"></figure>
<ol>
<li>用户程序中的MapReduce库首先会将输入数据划分为M份，通常每份是16M到64M，用户可以通过参数来设置。然后在集群里启动程序的复制。</li>
<li>有一个程序的复制是特殊的——<code>master</code>。余下节点的工作是由这个节点分配的。一共M个map任务和R个reduce任务需要分配。maste挑选空闲的worker，然后分配给它一共map任务或者一个reduce任务。</li>
<li>一个被分配了map任务的worker会读取相应划分的输入数据。它会将输入数据解析为键值对，然后传递给用户定义的map函数。map函数生成中间键值对，并缓存到内存里。</li>
<li>内存里的键值对会周期性的写入本地磁盘，并有分割函数划分为R个区域。本地磁盘上写入的键值对位置会被传回给master，然后master传递给reduce worker。</li>
<li>当一个reduce worker被master通知键值对位置，它会使用远程调用去读取远程磁盘上的由map生成的数据。当一个reduce worker读取了所有的中间数据，它会将所有的中间数据按照key进行排序，这样具有相同key的数据可以分组到一起。排序是必要的，因为通常会有许多不同的key映射到一个reduce任务上。如果中间数据的数量太大，需要使用外排序。</li>
<li>reduce worker遍历排好序的中间数据，然后对于每一个key，会将对应的key和value集合传递给用户的reduce函数。reduce函数的输出会添加到当前reduce划分的最终输出文件</li>
<li>当所有的map和reduce任务完成，master会唤醒用户程序。这时，用户程序里的<code>Mapreduce</code>调用会返回需要的结果。</li>
</ol>
<p>当成功完成后，MapReduce的输出会放在R个输出文件里。通常用户并不需要将这个R个文件合并为一个文件，他们可以将这些文件作为另一个MapReduce调用的输入，或者是使用其他可以处理多文件输入的分布式应用。</p>
<h3 id="32-master-data-structures">3.2 Master Data Structures</h3>
<p>master保持一些数据结构。对每一个map任务和reduce任务，它存储state（idle、in-processing,completed）,和工作机器标识。</p>
<p>master是map任务和reduce任务之间传递的中间文件的导管。因此，对每一个完成的map任务，master存储map产生的R个中间文件的位置和大小。当map任务完成时需要更新这些信息。这些信息会逐步推送到 in-process状态的reduce任务的worker上。</p>
<h3 id="33-fault-tolerance">3.3 Fault Tolerance</h3>
<p>MapReduce库的目的是在成千上万台机器上处理大量数据，因此必须优雅的处理机器错误。</p>
<h4 id="worker-failure">worker Failure</h4>
<p>master会周期性的ping每一个worker。如果在指定时间内没有收到worker的回复，master会将这个worker标记为failed 。每一个worker完成的map任务都会被重设为初始的idle状态，因此它可以被安排给其他worker。同样的，如果一个map或者reduce任务失败，它也会被设置为idle状态，然后被重新调度。</p>
<p>在一个失败机器上完成的map任务需要重新执行，因为它的输出存储在失败机器的本地硬盘上，是无法访问的。在一个失败机器上完成的reduce任务需要重新执行，因为它的输出存储在全局文件系统。</p>
<p>当一个map任务首先在worker A上执行然后在workerB上执行（因为A失败了），所有的的reduce worker会被通知重新执行。每个还没在worker A上读取数据的reduce任务会到worker B上读取。</p>
<p>MapReduce对大规模的worker失败是有弹性的。比如，执行一个MapReduce操作时，一个集群的网络维护会导致80台机器在一段时间内无法访问。MapReduce master只需要简单地重新执行一下由那些失败worker执行的任务，然后继续处理，知道完成MapReduce操作。</p>
<h4 id="master-failure">Master Failure</h4>
<p>很容易做到周期性地将上述master的数据结构存储到检查点。如果master任务失败，一份拷贝会从最近的检查点重新开始。然而，考虑到只有一个master节点，失败是不太可能的。因此我们最近的实现，在master失败的时候会终止MapReduce程序。客户端可以检查这个条件，或者重新尝试MapReduce操作。</p>
<h4 id="semantics-in-the-presence-of-failures">Semantics in the Presence of Failures</h4>
<p>当用户提供的map和reduce函数有着确定的输出时，我们的分布式执行结果会和整个程序无错误执行的输出相同。</p>
<p>我们这个属性的实现依赖于map和reduce任务输出的原子性提交。每一个执行中的任务会将其输出写入到私有存储文件中。一个reduce任务产生一个文件，一个map任务产生m个文件。当一个map任务完成时，worker会发送一个消息到master，这个消息里包含R个临时文件的name。如果master接收到一个一个已经完成的map任务的信息，将忽略这条信息。相反的，master将记录着R个文件的name。</p>
<p>当一个reduce任务完成时，reduce worker将原子地将临时文件重命名为最终输出文件。如果同一个reduce任务在许多机器上运行，重命名调用将调用多次。我们依赖于基础文件系统提供的原子重命名操作来保证最终文件系统状态仅包含一个reduce任务产生的数据。</p>
<p>我们的大部分map和reduce操作是确定性的，事实上我们的语义等价于一系列串行化操作，来使得程序员可以轻松地思考程序的表现。当map和reduce操作是不确定的，我们提供了较弱但是仍然合理的语义。在不确定操作的情况下，某一特定reduce任务<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的输出等价于不确定程序的某个串行化操作的输出。然鹅，另一个reduce任务<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的输出可能由于不确定任务执行顺序的不同而不同。</p>
<p>考虑map任务M和reduce任务<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_1,R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的情况。我们设定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>(</mo><msub><mi>R</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">e(R_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>为已经提交的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的执行(有且仅有一个这样的执行)。这个比较弱的语义出现,因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>(</mo><msub><mi>R</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">e(R_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>也许已经读取了由M的执行产生的输出,而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>(</mo><msub><mi>R</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">e(R_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>也许已经读取了由M的不同执行产生的输出.</p>
<h3 id="34-locality">3.4 Locality</h3>
<p>在我们的计算环境中，网络带宽是比较珍贵的资源。我们采用将输入数据（GFS管理）保存到组成集群的机器的本地磁盘上来节省带宽。GFS将每个文件分割为64MB大小的块，然后每个块存储多个拷贝（通常3个）在不同的机器上。MapReduce master将输入文件的位置位置信息考虑在内，并尝试在包含输入数据的副本的机器上进行map任务。如果失败，它将尝试在该任务输入数据的副本附近安排map任务（例如，在与包含数据的计算机位于同一网络交换机的工作计算机上）。 在集群中相当大部分的工作线程上运行大型MapReduce操作时，大多数输入数据都在本地读取，并且不占用网络带宽。</p>
<h3 id="35-task-granularity">3.5 Task Granularity</h3>
<p>如上所述，我们将map阶段细分为M份，将reduce阶段细分为R份。理想情况下，MR应该比worker机器的数量大的多。每个worker执行许多不同的任务可以改善动态负载平衡，还可以使得失败快速恢复：这个机器上的许多已经完成的map任务可以被分配到所有其他的worker机器上。</p>
<p>在我们的实现中，MR的大小是有范围的，因为master必须做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>M</mi><mo>+</mo><mi>R</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(M+R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>次调度，并存储<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>M</mi><mo>×</mo><mi>R</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(M\times R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>个状态在内存中。（内存使用的常数因子是很小的，但是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>M</mi><mo>×</mo><mi>R</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(M\times R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> 块状态由大约每个 map 任务/reduce 任务对一个字节组成。</p>
<p>此外，R通常由用户指定，因为每个reduce任务最终会输出多个文件。在实践中，我们倾向于选择M使得每一个任务只需要处理16到64MB的输入数据（这样上述的本地化优化最有效）。R是我们希望使用的机器数量的一个小的倍数。通常对于一个MapReduce任务，我们使用2000台机器，M = 200000，R = 5000</p>
<h3 id="36-backup-tasks">3.6 Backup Tasks</h3>
<p>一个常见的导致MapReduce操作总时长过长的原因是&quot;straggler&quot;（落后者）：一台机器完成少量的Map或者Reduce任务但是花费了不正常的很长时间。落后者的出现可能有很多原因。比如，一个磁盘辣鸡的机器经常会遇到correctable errors  ，导致读写性能从30MB/s降到1MB/s。集群调度可能会在这台机器上安排其他任务，这就会导致CPU、磁盘、内存、带宽竞争，使得执行MapReduce代码非常缓慢。我们最近遇到的一个问题是，机器初始化代码中的一个bug导致处理器缓存被禁用，受影响的机器上计算速度下降了一百倍。</p>
<p>我们有一个通用的机制来减轻落后者带来的问题。当一个MapReduce操作接近完成时，master会调度其余正在运行中的任务的备份执行。无论是主任务还是备份任务完成，这个任务都会被标记为完成。我们已经对这个机制进行了调整，通常，计算资源的增加不超过百分之几。我们发现这对减小大型MapReduce操纵的时间是很有意义的。例如，5.3中的排序任务在禁用备份机制的时候，花费的时间会增长44%。</p>
<h2 id="4-技巧">4 技巧</h2>
<p>尽管对大部分需求来说，编写map和reduce函数提供的基础功能已经是足够的，但我们有一些有用的拓展。这一节将说明。</p>
<h3 id="41-partitioning-function">4.1 Partitioning  Function</h3>
<p>用户指定reduce任务的数量R。分割函数基于中间key将数据分割到这些任务上。一个默认的分割函数是使用hash（例如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo>(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>R</mi></mrow><annotation encoding="application/x-tex">hash(key)\mod R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>） 。这倾向于一个非常公平的划分。然鹅在某些情况下，使用某些其他的函数划分数据是非常有用的。例如，有时输出key是URL，我们希望某个主机的所有相关记录都在一个输出文件上。为了支持这种情况，用户可以提供一个特殊的划分函数，比如使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo>(</mo><mi>H</mi><mi>o</mi><mi>s</mi><mi>t</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>(</mo><mi>u</mi><mi>r</mi><mi>l</mi><mi>k</mi><mi>e</mi><mi>y</mi><mo>)</mo><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>R</mi></mrow><annotation encoding="application/x-tex">hash(Hostname(urlkey))\mod R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>作为划分函数，这样可以使得同一个主机的所有URL都在同一个输出文件中。</p>
<h3 id="42-ordering-guarantees">4.2 Ordering Guarantees</h3>
<p>我们保证对于一个给定的划分，中间键值对会按照key递增的顺序进行处理。这样的顺序保证可以使得很容易生成一个排好序的输出文件，这对输出文件支持按照key随机访问时很有效的，或者是输出文件是排序好的对用户很方便。</p>
<h3 id="43-combiner-function">4.3 Combiner Function</h3>
<p>在某些情况下，每个map任务产生的中间key会有大量重复，用户指定的reduce函数是可交换的和关联的。一个很好的例子是2.1节中的单词计数例子。单词频率一般遵循齐夫(Zipf)分布，每一个map任务会产生大量的<code>&lt;the,1&gt;</code>记录。所有的这些记录会通过网络发送到一个reduce函数中，然后由reduce函数加到一起产生一个数字。我们允许用户指定一个Combiner函数，在网络发送前对数据进行分区合并。</p>
<p>Combiner函数会在每个运行map任务的机器上执行。通常，combiner和reduce函数的实现代码是相同的。reduce函数和combiner函数的唯一区别是，MapReduce库是如何处理函数输出的。combiner函数的输出会被写入到一个中间文件中，然后被发送给一个reduce任务。</p>
<p>分区合并对特定MapReduce操作的加速是很明显的。附录A包含一个使用combiner的例子。</p>
<h3 id="44-input-and-output-types">4.4 Input and Output Types</h3>
<p>MapReduce库支持读取多种格式的输入数据。例如，text格式的输入会将每一行作为一个键值对，key是文件中的偏移值，value是每一行的内容。另一个比较常见支持的格式是按照key排序好的键值对序列。每一个输入类型的实现知道如何划分输入为有意义的range，以便map任务进行处理。用户可以通过提供一个简单的reader接口的实现来添加对一个新的输入类型的支持。</p>
<p>一个reader不一定从文件中读取内容。例如，定义一个从数据库读取记录或者从内存中读取数据结构映射是非常简单的。</p>
<p>同样的方式，我们支持一系列输出类型。添加新的输出类型是很简单的。</p>
<h3 id="45-side-effects">4.5 Side-effects</h3>
<p>在某些情况下，MapReduce的用户会发现将它们的map或者reduce操作生成辅助文件作为额外输出很方便。我们依赖于应用的writer来保证这些side-effect的原子性和幂等性。通常，应用会先写入到一个临时文件中，然后等它全部完成再原子性的重命名文件。</p>
<p>对于一个任务产生的多个输出文件，我们没有提供原子性的两阶段提交。因此，输出多个文件的任务的跨文件一致性需要是确定性的。这种限制在实践中从来不是问题</p>
<h3 id="46-skipping-bad-records">4.6 Skipping Bad Records</h3>
<p>有些时候因为用户代码里的bug导致map或者reduce函数在某个记录上崩溃。这样的bug会阻止MapReduce任务完成。通常的做法是修复这个bug，但是有时无法修复，这个bug可能在第三方库你无法更改源代码。另外，有时你需要忽略某些记录，例如在在某个大数据集上进行静态分析。我们提供了一个可选的运行方式，让MapReduce库发现哪些记录会导致崩溃，然后跳过这些记录，继续进行。</p>
<p>每一个worker进行会有一个信号handle来捕获段错误和总线错误。在调用一个用户的Map和reduce操作之前，MapReduce库将参数的序列号存储到全局变量里。如果用户代码产生一个信号，信号handler发送一个“last gasp” UDP  包，包含序列号，到MapReducemaster上当master发现在某一个记录上有多次失败，这表明在下一次重新执行时应该跳过这条记录。</p>
<h3 id="47-local-execution">4.7 Local Execution</h3>
<p>map、reduce函数的debug问题很棘手。因为实际的计算是在一个分布式系统上，通常会有几千台机器，有master动态地分配任务。为了方便debug和小规模测试，我们专门做了一个实现，可以在本地机器上执行MapReduce操作。用户提供控制，这样计算可以限制到某一特定的map任务上。用户通过一个特殊的标志位调用他们的程序，然后简单地使用任何他们使用的debug或者测试工具。</p>
<h3 id="48-status-information">4.8 Status Information</h3>
<p>master运行一个内部HTTP服务器，并导出一组状态页供人类使用。状态页显示计算进度,像多少个任务已经完成,多少个还在运行,输入的字节数,中间数据字节数,输出字节数,处理百分比,等等.这个页也包含到标准错误的链接,和由每个任务产生的标准输出的链接.用户可以根据这些数据预测计算需要花费的时间,和是否需要更多的资源.当计算比预期的要慢很多的时候,这些页面也可以被用来判断是不是这样.</p>
<p>此外,最上面的状态页显示已经有多少个worker失败了,和当它们失败的时候,那个map和reduce任务正在运行.当试图诊断在用户代码里的bug时,这个信息也是有用的.</p>
<h3 id="49-counters">4.9 Counters</h3>
<p>MapReduce库提供一个计数器来计算各种时间的发生次数。例如，用户想要统计所有单词处理的次数或者德语文档被索引的次数。</p>
<p>为了使用这个功能，用户需要创建一个命名计数器对象，然后在map或者reduce函数里适当的增加技术，例如：</p>
<pre><code>Counter* uppercase;
uppercase = GetCounter(&quot;uppercase&quot;);

map(String name, String contents):
	for each word w in contents:
		if (IsCapitalized(w)):
			uppercase-&gt;Increment();
		EmitIntermediate(w, &quot;1&quot;)
</code></pre>
<p>每台worker机器上的计数值都会周期性地发送到master上（依附在ping回应上）。master从成功的map和reduce任务里统计计数值，然后当MapReduce任务完成时返回给用户代码。当前计数值也会在master的状态页上展示，这样人类可以观察计算过程。当统计计数值的时候，master会同一个map/reduce任务多次执行的影响，避免重复计数。</p>
<p>部分计数值会被MapReduce库自动维护，比如输入输出的键值对数</p>
<p>用户会发现，对MapReduce操作的合理性检查(sanity checking)是很有用的。例如，在某些MapReduce操作中，用户代码可能想要保证输出的键值对数等于输入的键值对数，或者是处理的德语文档在一个合理 的比例之内。</p>
<h2 id="5-性能">5 性能</h2>
<p>两个实例的benchmark，略</p>
<h2 id="6-经验">6 经验</h2>
<p>吹了一点MapReduce的用途和性能，略</p>
<h2 id="7-相关工作">7 相关工作</h2>
<p>略</p>
<h2 id="a-单词频率统计">A 单词频率统计</h2>
<p>本节包含了一个完整的程序,用于统计在一组命令行指定的输入文件中,每一个不同的单词出现频率.</p>
<pre><code class="language-cpp">#include &quot;mapreduce/mapreduce.h&quot;
// User’s map function
class WordCounter : public Mapper {
public:
	virtual void Map(const MapInput&amp; input) {
		const string&amp; text = input.value();
		const int n = text.size();
		for (int i = 0; i &lt; n; ) {
			// 跳过开始时的空白
			while ((i &lt; n) &amp;&amp; isspace(text[i]))
				i++;
			// 查找单词结尾
			int start = i;
			while ((i &lt; n) &amp;&amp; !isspace(text[i]))
				i++;
			if (start &lt; i)
				Emit(text.substr(start,i-start),&quot;1&quot;);
		}
	}
};
REGISTER_MAPPER(WordCounter);

// User’s reduce function
class Adder : public Reducer {
	virtual void Reduce(ReduceInput* input) {
		// 遍历所有相同key的条目，然后把值加到一起
		int64 value = 0;
		while (!input-&gt;done()) {
			value += StringToInt(input-&gt;value());
			input-&gt;NextValue();
		}
		// Emit sum for input-&gt;key()
		Emit(IntToString(value));
	}
};
REGISTER_REDUCER(Adder);

int main(int argc, char** argv) {
	ParseCommandLineFlags(argc, argv);
	MapReduceSpecification spec;
	// 将输入文件列表存储到 &quot;spec&quot;
	for (int i = 1; i &lt; argc; i++) {
		MapReduceInput* input = spec.add_input();
		input-&gt;set_format(&quot;text&quot;);
		input-&gt;set_filepattern(argv[i]);
		input-&gt;set_mapper_class(&quot;WordCounter&quot;);
	}
	// 指定输出文件:
	// /gfs/test/freq-00000-of-00100
	// /gfs/test/freq-00001-of-00100
	// ...
	MapReduceOutput* out = spec.output();
	out-&gt;set_filebase(&quot;/gfs/test/freq&quot;);
	out-&gt;set_num_tasks(100);
	out-&gt;set_format(&quot;text&quot;);
	out-&gt;set_reducer_class(&quot;Adder&quot;);
	// 可选项：局部求和节省带宽
	out-&gt;set_combiner_class(&quot;Adder&quot;);
	// Tuning parameters: use at most 2000
	// machines and 100 MB of memory per task
	spec.set_machines(2000);
	spec.set_map_megabytes(100);
	spec.set_reduce_megabytes(100);
	// Now run it
	MapReduceResult result;
	if (!MapReduce(spec, &amp;result)) abort();
	// Done: ’result’ structure contains info
	// about counters, time taken, number of
	// machines used, etc.
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[牛客等级之题 (8.3场)]]></title>
        <id>https://codemogg.cn/post/I4i9VdugM/</id>
        <link href="https://codemogg.cn/post/I4i9VdugM/">
        </link>
        <updated>2020-08-03T13:34:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="n2"><a href="https://ac.nowcoder.com/acm/contest/6765#question">N2</a></h2>
<p>设左右半径为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">r_1,r_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>则红色部分面积为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>π</mi><mn>2</mn></mfrac><mo>[</mo><mo>(</mo><msub><mi>r</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>2</mn></msub><msup><mo>)</mo><mn>2</mn></msup><mo>−</mo><msubsup><mi>r</mi><mn>1</mn><mn>2</mn></msubsup><mo>−</mo><msubsup><mi>r</mi><mn>2</mn><mn>2</mn></msubsup><mo>]</mo><mo>=</mo><mi>π</mi><msub><mi>r</mi><mn>1</mn></msub><msub><mi>r</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\frac{\pi}{2}[(r_1+r_2)^2 -r_1^2-r_2^2] = \pi r_1r_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">r_1+r_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为定值时，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>=</mo><msub><mi>r</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">r_1=r_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时，红色部分面积最大</p>
<p>反过来红色部分面积为定值时，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>=</mo><msub><mi>r</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">r_1=r_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时，大圆半径最小，为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><msqrt><mfrac><mi>s</mi><mi>π</mi></mfrac></msqrt></mrow><annotation encoding="application/x-tex">2\sqrt{\frac{s}{\pi}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.37980400000000003em;"></span><span class="mord">2</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.860196em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.820196em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.37980400000000003em;"><span></span></span></span></span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

const double pi = acos(-1);

int main(int argc, char* argv[])
{
    double n;
    cin &gt;&gt; n;
    printf(&quot;%.3lf&quot;, 2.0 * sqrt(n / pi));
}

</code></pre>
<h2 id="n1"><a href="https://ac.nowcoder.com/acm/contest/6766#question">N1</a></h2>
<p>这题推起来还挺麻烦的</p>
<p>先推第一轮，黑球的数目有三种情况<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo separator="true">,</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1,n,n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>对应的概率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo>)</mo></mrow><mrow><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo separator="true">,</mo><mfrac><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi>p</mi><mo>+</mo><mo>(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo>)</mo></mrow><mrow><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo separator="true">,</mo><mfrac><mrow><mi>m</mi><mi>p</mi></mrow><mrow><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(1-p)}{n+m+1},\frac{(n+1)p + (m+1)(1-p)}{n+m+1},\frac{mp}{n+m+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.413331em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">p</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mathdefault mtight">p</span><span class="mbin mtight">+</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">p</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，所以第一轮黑球的期望是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mo>(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>)</mo><mo>(</mo><mi>p</mi><mo>+</mo><mi>n</mi><mo>)</mo></mrow><mrow><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{(m+n)(p+n)}{n+m+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.413331em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">p</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>相应的我们可以推出蓝球期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mo>(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>)</mo><mo>(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo>)</mo></mrow><mrow><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{(m+n)(m+1-p)}{n+m+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.413331em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">p</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>不难发现两种期望的和是n+m，所以球的总数是不会变的 <s>（废话）</s>  。</p>
<p>假设第<code>i</code>轮黑球的数目为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n_i,n_0=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> ，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>=</mo><mi>x</mi><mo>(</mo><mi>p</mi><mo>+</mo><msub><mi>n</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">n_i = x(p+n_{i-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mfrac><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">x = \frac{m+n}{m+n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.205662em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.802331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>为定值</p>
<p>剩下的就不难推了，拆开就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>=</mo><mi>x</mi><mi>p</mi><mfrac><mrow><mn>1</mn><mo>−</mo><msup><mi>x</mi><mi>i</mi></msup></mrow><mrow><mn>1</mn><mo>−</mo><mi>x</mi></mrow></mfrac><mo>+</mo><mi>n</mi><msup><mi>x</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">n_i = xp\frac{1-x^i}{1-x} + nx^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.428791em;vertical-align:-0.403331em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0254599999999998em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9020857142857143em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;

ll qp(ll a, ll b)
{
    ll res = 1;
    while (b)
    {
        if (b &amp; 1) res = (res * a) % mod;
        a = (a * a) % mod;
        b &gt;&gt;= 1;
    }
    return res;
}

int main(int argc, char* argv[])
{
    ll n, m, k, a, b;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; a &gt;&gt; b;
    ll x = ((n + m) * qp(n + m + 1, mod - 2)) % mod;
    ll p = a * qp(b, mod - 2) % mod;
    ll xk = qp(x, k);
    cout &lt;&lt; (p * (n + m - (n + m) * qp(x, k) % mod + mod) + xk * n) % mod;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 第 31 场双周赛]]></title>
        <id>https://codemogg.cn/post/gEGl4gH-j/</id>
        <link href="https://codemogg.cn/post/gEGl4gH-j/">
        </link>
        <updated>2020-08-02T13:53:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1524-和为奇数的子数组数目"><a href="https://leetcode-cn.com/problems/number-of-sub-arrays-with-odd-sum/">1524. 和为奇数的子数组数目</a></h2>
<p>前缀和，如果当前和为奇数，答案加上前面为偶数的个数，反之亦然。</p>
<pre><code class="language-cpp">int numOfSubarrays(vector&lt;int&gt;&amp; arr) {
    const int mod = 1e9 + 7;
    int a = 0, b = 1, res = 0, sum = 0;
    for (int i = 0; i &lt; arr.size(); ++i)
    {
        sum += arr[i];
        if (sum &amp; 1)
        {
            res += b;
            a++;
        }
        else
        {
            res += a;
            b++;
        }
        res %= mod;
    }
    return res;
}
</code></pre>
<h2 id="1525-字符串的好分割数目"><a href="https://leetcode-cn.com/problems/number-of-good-ways-to-split-a-string/">1525. 字符串的好分割数目</a></h2>
<p>这也没啥说的，正反统计一遍就行</p>
<pre><code class="language-cpp">vector&lt;int&gt; cnt(const string&amp; s)
{
    set&lt;char&gt;cs;
    vector&lt;int&gt; res(s.size(), 0);

    for (int i = 0; i &lt; s.size(); ++i)
    {
        cs.insert(s[i]);
        res[i] = cs.size();
    }
    return res;
}

int numSplits(string s) {
    vector&lt;int&gt; n1 = cnt(s);
    reverse(s.begin(), s.end());
    vector&lt;int&gt; n2 = cnt(s);
    int res = 0, n = s.size();
    for (int i = 0; i &lt; n - 1; ++i)
    {
        res += n1[i] == n2[n - i - 2];
    }
    return res;
}
</code></pre>
<h2 id="1526-形成目标数组的子数组最少增加次数"><a href="https://leetcode-cn.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/">1526. 形成目标数组的子数组最少增加次数</a></h2>
<p>数组的变化趋势是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>↗</mo><mo>↘</mo><mo>↗</mo><mo>↘</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\nearrow\searrow\nearrow\searrow\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel">↗</span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel">↘</span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel">↗</span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel">↘</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span>，显然最小次数是波峰-波谷，对第一段来说波谷是0，对后面来说是衔接处的值。</p>
<p>找波峰波谷比较麻烦，事实上我们只需要对上升阶段的差值求和即可。</p>
<pre><code class="language-cpp">int minNumberOperations(vector&lt;int&gt;&amp; target) {
    int res = target[0];
    for (int i = 1; i &lt; target.size(); ++i)
    {
        res += max(0, target[i] - target[i - 1]);
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 第 199 场周赛题解]]></title>
        <id>https://codemogg.cn/post/leetcode-199/</id>
        <link href="https://codemogg.cn/post/leetcode-199/">
        </link>
        <updated>2020-07-31T04:46:00.000Z</updated>
        <content type="html"><![CDATA[<p>自从实习跑路之后，最近又开始摸了起来（x）</p>
<p>实习工资换了新电脑，爽了一个月之后进入贤者时间，无聊就开始刷刷题。</p>
<p>懒得在新电脑上配一遍hexo，之前的博客就这样扔了吧。翻了翻国内的博客网站，CSDN屑，博客园有点麻烦，牛客丑。</p>
<p>挑来挑去还是决定用gridea+gitpage，之前的博客有时间补一补吧。</p>
<p>力扣周赛老是忘记打，平时补补题。</p>
<p>cf时间点不太好，在家太晚不方便开灯，先补题，开学再打。</p>
<h2 id="1528-重新排列字符串"><a href="https://leetcode-cn.com/problems/shuffle-string/">1528. 重新排列字符串</a></h2>
<p>水题</p>
<h2 id="1529-灯泡开关-iv"><a href="https://leetcode-cn.com/problems/bulb-switcher-iv/">1529. 灯泡开关 IV</a></h2>
<p>一串1翻转出来和一个1是一样的。</p>
<p>开始的0不用考虑，存不存在都一样。</p>
<p>对于<code>101010...</code>这样的字符串来说，只需要<code>2n</code>次，n是1的个数。如果最后是1不是0的话减一。</p>
<pre><code class="language-cpp">int minFlips(string target) {
    int res = 0;
    bool out = true;
    for (size_t i = 0; i &lt; target.size(); ++i)
    {
        if(target[i] == '1' &amp;&amp; out)
        {
            out = false;
            res++;
        }
        else if(target[i] == '0')
        {
            out = true;
        }
    }
    return  res * 2 - 1 + (*target.rbegin() == '0');
}
</code></pre>
<h2 id="1530-好叶子节点对的数量"><a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/">1530. 好叶子节点对的数量</a></h2>
<p>比较明显的树形dp。记录一下距离当前节点cur距离为x的（子树上的）叶子结点个数，然后左孩子和右孩子距离和小于distance的记录一下即可。</p>
<p>坑的是节点的val是有重复的，需要字节再计一下。</p>
<p>这题可以改造一下，二叉树改成多叉（</p>
<pre><code class="language-cpp">int cnt[2048][16];
int tot,res;
// Return node id after reordering
int dfs(TreeNode* root, int distance)
{
    ++tot;
    int cur = tot;
    int l = 0, r = 0;
    if (root-&gt;left)l = dfs(root-&gt;left, distance);
    if (root-&gt;right)r = dfs(root-&gt;right, distance);
    if (l == 0 &amp;&amp; r == 0) cnt[cur][0]++;
    for (int i = 1; i &lt; 16; ++i)
    {
        cnt[cur][i] += cnt[l][i - 1] + cnt[r][i - 1];
    }
    for (int i = 1; i &lt; distance; ++i)
    {
        for (int j = 1; j &lt;= distance - i; ++j)
        {
            res += cnt[l][i-1] * cnt[r][j-1];
        }
    }
    return cur;
}
int countPairs(TreeNode* root, int distance) {
    res = 0; tot = 0;
    dfs(root, distance);
    return res;
}
</code></pre>
<h2 id="1531-压缩字符串-ii"><a href="https://leetcode-cn.com/problems/string-compression-ii/">1531. 压缩字符串 II</a></h2>
<p>挺好一题。</p>
<p>一开始想的是贪心，优先把接近1、2、10、100的字母剪一剪，因为这几个数减一之后整体长度数量会减小。但是没法处理<code>aabbaa</code>,2这组数据，因为bb删除之后a会连到一起。</p>
<p>考虑dp解法。删除不超过k个字符，等价于选取<code>s.size()-k</code>个字符。因为多删结果只会更优或者相等，不会更差，所以我们删除k个。</p>
<p>观察最终字符，一定是一段段连续的字母拼成的<s>其实原始字符也是这样</s>，那么我们在dp的时候，选择第<code>i</code>个字符后，只需要考虑选取后面和<code>s[i]</code>相同的字符即可。</p>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示从i开始，一共选择了j个字符的最优解。</p>
<p>选取i时:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><munderover><mi>min</mi><mo>⁡</mo><mrow><mi>a</mi><mo>=</mo><mi>i</mi></mrow><mrow><mi>s</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>(</mo><mo>)</mo></mrow></munderover><mi>c</mi><mi>p</mi><mo>(</mo><mi>s</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>a</mi><mo>)</mo><mo>)</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>a</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mi>s</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>a</mi><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = \min\limits_{a=i}^{s.size()} cp(same(i,a)) + dp[a+1][j-same(i,a)]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.306524em;vertical-align:-0.727664em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5788600000000002em;"><span style="top:-2.072336em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">min</span></span></span><span style="top:-3.65386em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mtight">.</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mathdefault mtight">e</span><span class="mopen mtight">(</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.727664em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p>
<p>其中<code>cp</code>表示x个相同字符压缩后的长度，<code>same(i,j)</code>表示区间<code>[i,j]</code>中与<code>s[i]</code>相同的字符个数。</p>
<p>不选i时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=dp[i+1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></p>
<p>注意初始化。</p>
<pre><code class="language-cpp">int cp(int x)
{
    if (x &lt;= 1) return 1;
    if (x &lt; 10) return 2;
    if (x &lt; 100) return 3;
    return 4;
}
int dp[101][101];
int getLengthOfOptimalCompression(string s, int k) {
    k = s.size() - k;
    memset(dp, 0x3f, sizeof(dp));
    const int INF = 0x3f3f3f3f;
    dp[s.size()][0] = 0;
     for (int i = s.size() - 1; i &gt;= 0; --i)
    {
        for (int j = 0; j &lt;= k; ++j)
        {
            if (dp[i + 1][j] &lt; INF)
                dp[i][j] = dp[i + 1][j];
            else break;
        }
        int cnt = 0;
        for (int j = i; j &lt; s.size(); ++j)
        {
            if (s[j] == s[i]) cnt++;
            for (int a = 0; a + cnt &lt;= k; ++a)
            {
                if (dp[j + 1][a] &lt; INF)
                    dp[i][a + cnt] = min(dp[i][a + cnt], dp[j + 1][a] + cp(cnt));
                else break;
            }
        }
    }
    return dp[0][k];
}
</code></pre>
]]></content>
    </entry>
</feed>