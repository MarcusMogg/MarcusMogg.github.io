---
title: 'Linux 常用命令'
date: 2020-10-21 23:57:09
tags: []
mathjax: true
---
一些基础知识和命令的笔记

## shell
tab 补全
`ctrl+u`从光标处向前删除指令串
`ctrl+k`从光标处向后删除指令串
### 变量

变量的设定规则
1. 变量与变量内容以一个等号`=`来连结，如：`myname=VBird`
2. 等号两边不能直接接空格符，所示为错误：`myname = VBird`或`myname=VBird Tsai`
3. 变量名称只能是英文字母与数字，但是开头字符不能是数字，如下为错误：`2myname=VBird`
4. 变量内容若有空格符可使用双引号`"`或单引号`'`将变量内容结合起来，但:
        - 双引号内的特殊字符如 $ 等，可以保有原本的特性，如下所示：
           `var="lang is $LANG"`则`echo $var`可得`lang is zh_TW.UTF-8`
       - o 单引号内的特殊字符则仅为一般字符 (纯文本)，如下所示：
           `var='lang is $LANG'`则`echo $var`可得`lang is $LANG`
5. 可用字符` \ `将特殊符号(如 [Enter], $, \, 空格符, '等)变成一般字符，如：
`myname=VBird\ Tsai`
1. 在一串指令的执行中，还需要藉由其他额外的指令所提供的信息时，可以使用反单引号\`指令\` 或`$(指令)` 。例如想要取得核心版本的设定：
`version=$(uname -r)`再`echo $version`可得`3.10.0-229.el7.x86_64`
7. 若该变量为扩增变量内容时，则可用 `"$变量名称" `或` ${变量} `  累加内容，如下所示：
`PATH="$PATH":/home/bin`或`PATH=${PATH}:/home/bin`
8. 若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量：`export PATH`
9. 通常大写字符为系统默认变量，自行设定变量可以使用小写字符，方便判断 (纯粹依照使用者兴趣与嗜好) ；
10. 取消变量的方法为使用 unset ：`unset 变量名称`例如取消 myname 的设定：
`unset myname`
### 环境变量

`env` 查看
`export`设置

### 通配符

`*` 代表任意多个字符
`?` 代表一个任意字符
`[ ]` 代表一定有一个在括号内的字符(非任意字符)。例如 [abcd] 代表一定有一个字符， 可能是 a, b,
c, d 这四个任何一个
`[ - ]`若有减号在中括号内时，代表在编码顺序内的所有字符。例如 [0-9] 代表 0 到 9 之间的所有数字，
`[^ ]`若中括号内的第一个字符为指数符号 (^) ，那表示『反向选择』，例如 [^abc] 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思


## find

`find [path] [option] [action]`

path 不必多说

option 

```
-mtime n ：n 为数字，意义为在 n 天之前的『一天之内』被更动过内容的文件；
-mtime +n ：列出在 n 天之前(不含 n 天本身)被更动过内容的文件档名；
-mtime -n ：列出在 n 天之内(含 n 天本身)被更动过内容的文件档名。
-newer file ：file 为一个存在的文件，列出比 file 还要新的文件档名

-user name ：name 为使用者账号名称
-uid n ：n 为数字，这个数字是用户的账号 ID
-name filename：搜寻文件名为 filename 的文件；
-size [+-]SIZE：搜寻比 SIZE 还要大(+)或小(-)的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes
-type TYPE ：搜寻文件的类型为 TYPE 的，类型主要有：普通文件 (f), 装置文件 (b, c),目录 (d), 连结档 (l), socket (s), 及 FIFO (p) 等属性
```
示例

```shell
find allocator/ iterator/ sequence_containers/ -type f -name '*.c' -o -name '*.cpp' -o -name '*.h'
```
-o 表示 or或者
-a 表示 and与
默认会使用-a

## tar

`tar [-z|-j|-J] [cv] [-f 输出的文件名] filename... <==打包与压缩`
`tar [-z|-j|-J] [xv] [-f 既有的 tar 文件名] [-C 目录] <==解压缩`

```
-z ：透过 gzip 的支持进行压缩/解压缩：此时档名最好为 *.tar.gz
-j ：透过 bzip2 的支持进行压缩/解压缩：此时档名最好为 *.tar.bz2
-J ：透过 xz 的支持进行压缩/解压缩：此时档名最好为 *.tar.xz
-v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来
-c ：建立打包文件
-x :  解压缩
```

-f 可以和前面的合并到一起，比如解压可以写成
```
tar -zxv -f filename.tar.gz -C out/
tar -zxvf filename.tar.gz -C out/
```

## vim

### 一般模式
默认进入界面
esc 也会进入

#### 移动

`hjkl` 对应 `← ↓ ↑ →`   如果先打数字再输对应的字符之后可以移动对应的次数，比如50l 相当于50次l

`ctrl + f` 向下跳一页 相当于 pagedown
`ctrl + b` 向上跳一页 相当于 pageup
`ctrl + d` 向下跳半页 
`ctrl + u` 向上跳半页 

`+` 光标移动到下一行开始非空格符的位置
`-` 光标移动到上一行开始非空格符的位置

`[num] + space`   向后移动num个字符，`[num] + l`的区别是 space可以移动到下一行 l不会 

`0` 或者 home 移动到行首
`$` 或者 end 移动到行首

`G ` 移动到文件最后一行开始
`num G ` 移动到文件第n行开始
`gg`移动到文件第一行开始
`num <Enter>` 向下移动num行

#### 复制粘贴删除
`x` 相当于 del
`X` 相当于 backspace
`num x|X` 执行num次x或者X

`dd` 删除一行
`num dd` 删除nun行
`d0` 删除光标所在位置到该行的开始
`d$` 删除光标所在位置到该行的结束

`yy` 复制一行
`num yy` 复制nun行
`y0` 复制光标所在位置到该行的开始
`y$` 复制光标所在位置到该行的结束

`p` 粘贴 如果复制的是一行（yy）则粘贴到下一行，如果复制的是部分数据，粘贴到当前字符的后面
`P` 粘贴 如果复制的是一行（yy）则粘贴到上一行，如果复制的是部分数据，粘贴到当前字符的前面

`u` 撤销上一个操作
`ctrl + r` 重做上一个操作

#### 区块选择
`v` 进入选择模式，按字符选
`V` 进入选择模式，按行选
`ctrl + V` 进入选择模式，按行选
### 编辑模式
一般模式下按`i I o O a A r R` 都可以进入
这个模式下输入文本

`i` 从光标处开始插入
`I` 从光标所在行的第一个非空白符开始插入
`a` 从光标处开始的下一个字符插入
`A` 从光标所在行的最后一个字符开始插入
`o` 往下插入新的一行
`O` 往上插入新的一行
`r` replace模式，只会取代一次，然后返回一般模式
`R`replace模式，一直取代

### 命令模式
一般模式下输入 `: / ?` 可以在左下角输入命令

#### 搜索
`/word` 向下找word这个字符串
`?word` 向上找word这个字符串
`n` 重复上一次搜寻动作
`N`反向重复上一次搜寻动作

#### 替换
`:num1,num2s/word1/word2/g` 将num1行到num2行中的所有word1替换为word2
`:1,$s/word1/word2/g` 将第一行到最后一行中的所有word1替换为word2
`:1,$s/word1/word2/gc` 将第一行到最后一行中的所有word1替换为word2，并且每一个替换会让你确认

#### 保存离开
`:w ` 将编辑的数据写入硬盘文件中
`:w!` 若文件属性为『只读』时，强制写入该文件。不过，到底能不能写入， 还是跟你对该文件的文件权限有关
`:q` 离开 vi 
`:q!` 若曾修改过文件，又不想储存，使用 ! 为强制离开不储存文件
注意一下，! 在 vi 当中，常常具有『强制』的意思
`:wq` 储存后离开，若为 `:wq!` 则为强制储存后离开 
ZZ 这是大写的 Z 喔！若文件没有更动，则不储存离开，若文件已经被更动过，则储存后离开！
`:w [filename]` 将编辑的数据储存成另一个文件
`:r [filename]` 在编辑的数据中，读入另一个文件的数据。亦即将 『filename』 这个文件内容加到游标所在列后面
`:n1,n2 w [filename]` 将 n1 到 n2 的内容储存成 filename 这个文件。
`:! command`暂时离开 vi 到指令列模式下执行 command 的显示结果！例如
『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的文件信息

#### 设置
`:set nu` 显示行号
`:set nonu` 与 set nu 相反，为取消行号

### 多文件编辑

vim file1 file2 file3...

`:n` 编辑下一个文件
`:N` 编辑上一个文件
`:files` 列出目前这个 vim 的开启的所有文件

`:sp [filename]` 开启一个新窗口，如果有加 filename， 表示在新窗口开启一个新文件，否则表示两个窗口为同一个文件内容(同步显示)。
`[ctrl]+w+ j` 或者`[ctrl]+w+↓` 按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j (或向下箭头键)，则光标可移动到下方的窗口。
`[ctrl]+w+ k` `[ctrl]+w+↑ `同上，不过光标移动到上面的窗口。
`[ctrl]+w+ q` 其实就是 :q 结束离开。如果想要结束下方的窗口，那么利用 [ctrl]+w+↓ 移动到下方窗口后，按下 :q 即可离开， 也可以按下 [ctrl]+w+q 

## grep
```shell
grep [-acinv] [--color=auto] '搜寻字符串' '输入的信息'

-a ：将 binary 文件以 text 文件的方式搜寻数据
-c ：计算找到 '搜寻字符串' 的次数
-i ：忽略大小写的不同，所以大小写视为相同
-n ：顺便输出行号
-v ：反向选择，即显示出没有 '搜寻字符串' 内容的那一行
```

grep一般和管道一起使用

比如
```shell
ls | grep 'root'
```
从ls输出的信息中筛选含有root的

搜寻字符串支持正则

## wc
```shell
wc [-lwm]

-l ：仅列出行；
-w ：仅列出多少字(英文单字)；
-m ：多少字符
```
统计字符数、行数

## tee
tee 会同时将数据流分送到文件去与屏幕 (stdout)

```shell
tee [-a] file
选项与参数：
-a ：以追加 (append) 的方式，将数据加入 file 当中！
```

## xargs
```shell
xargs [-0epn] command
选项与参数：
-0 ：如果输入的 stdin 含有特殊字符，例如 `, \, 空格键等等字符时，这个 -0 参数可以将他还原成一般字符
-e ：这个是 EOF (end of file) 的意思。后面可以接一个字符串，当 xargs 分析到这个字符串时，就会停止继续工作
-p ：在执行每个指令的 argument 时，都会询问使用者；
-n ：后面接次数，每次 command 指令执行时，要使用几个参数。
当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出
```

使用 xargs 的原因是， 很多指令其实并不支持管线命令，因此我们可以透过 xargs 来提供该指令引用 standard input 

比如
```shell
find /usr/sbin -perm /7000 | xargs ls -l
```

## sed

```
sed [-nefr] [动作]
选项与参数：
-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行(或者动作)才会被列出来。
-e ：直接在指令列模式上进行 sed 的动作编辑；
-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以执行 filename 内的 sed 动作；
-r ：sed 的动作支持的是延伸型正规表示法的语法。(预设是基础正规表示法语法)
-i ：直接修改读取的文件内容，而不是由屏幕输出。

动作说明： [n1,n2]function
n1 n2表示处理的行数
function
a ：新增， a 的后面可以接字符串，而这些字符串会在新的一行出现(目前的下一行)
c ：替换， c 的后面可以接字符串，这些字符串可以替换 n1,n2 之间的行
d ：删除，因为是删除啊，所以 d 后面通常不接任何内容
i ：插入， i 的后面可以接字符串，而这些字符串会在新的一行出现(目前的上一行)；
p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运作
s ：替换。这个 s 的动作可以搭配正则表达式，例如 1,20s/old/new/g
```

例子：

```shell
# 将 /etc/passwd 的内容列出并且打印行号，同时，将第 2~5 行删除
 nl /etc/passwd | sed '2,5d'
# 在第二行后加上 drink tea（新起一行）
 nl /etc/passwd | sed '2a drink tea'
 #将第 2-5 行的内容替换成为No 2-5 number
 nl /etc/passwd | sed '2,5c No 2-5 number'
# 搜寻并替换
 sed 's/要被替换的字符串/新的字符串/g'
 #将 regular_express.txt 内每一行结尾若为 . 则换成 !
 sed -i 's/\.$/\!/g' regular_express.txt
```

## awk

```
awk '条件类型 1{动作 1} 条件类型 2{动作 2} ...' filename
```

sed是将std的内容一行一行处理
awk也是一行，但是会按照空白符把每一行分成多个字段，每一行的每个字段都是有变量名称，从`$1`开始，然后`$2 $3...`  。`$0`表示一整行

例子
```shell
# 最近登录的五个账号，把第一个和第三个内容交个printf打印（printf也是个shell命令）
last -n 5 | awk '{print $1 "\t" $3}'
```

### 内建变量

|变量名称 |代表意义|
| - | - |
|NF |每一行 ($0) 拥有的字段总数|
|NR |目前 awk 所处理的是『第几行』数据|
|FS| 目前的分隔字符，默认是空格键|

### 逻辑运算字符

awk支持逻辑运算符：`> < != == <= >=

例子

```shell
# /etc/passwd 使用:作为分隔符
# 查阅第三列小于 10 以下的数据，并且仅列出账号与第三列
cat /etc/passwd | awk 'BEGIN {FS=":"} $3 < 10 {print $1 "\t " $3}'
````
`BEGIN`:读入第一行的时候 变量`$1`,`$2`... 默认还是以空格键为分隔的，所以虽然定义了 FS=":" 了， 但是仅能在第二行后才开始生效。 BEGIN就是解决这个问题

awk还可以使用自定义的变量
```shell
cat pay.txt | \
    awk 'NR==1{printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total" }
    NR>=2{total = $2 + $3 + $4
    printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'
# 输出
Name 1st 2nd 3th Total
VBird 23000 24000 25000 72000.00
DMTsai 21000 20000 23000 64000.00
Bird2 43000 42000 41000 126000.00
```